print({"id": "ensemble+unique_by_key-ensemble+EnsembleRetriever::weighted_reciprocal_rank", "project": "langchain", "raw_response": "<id>langchain.retrievers.ensemble.unique_by_key</id>\n```python\ndef unique_by_key(iterable: Iterable[T], key: Callable[[T], H]) -> Iterator[T]:\n    \"\"\"Yield unique elements of an iterable based on a key function.\n\n    Args:\n        iterable: The iterable to filter.\n        key: A function that returns a hashable key for each element.\n\n    Yields:\n        Unique elements of the iterable based on the key function.\n    \"\"\"\n    seen_keys = set()\n    for item in iterable:\n        k = key(item)\n        if k not in seen_keys:\n            yield item\n            seen_keys.add(k)\n```\n\n<id>langchain.retrievers.ensemble.EnsembleRetriever.weighted_reciprocal_rank</id>\n```python\n    def weighted_reciprocal_rank(\n        self, doc_lists: List[List[Document]]\n    ) -> List[Document]:\n        \"\"\"\n        Perform weighted Reciprocal Rank Fusion on multiple rank lists.\n        You can find more details about RRF here:\n        https://plg.uwaterloo.ca/~gvcormac/cormacksigir09-rrf.pdf\n\n        Args:\n            doc_lists: A list of rank lists, where each rank list contains unique items.\n\n        Returns:\n            list: The final aggregated list of items sorted by their weighted RRF\n                    scores in descending order.\n        \"\"\"\n        if len(doc_lists) != len(self.weights):\n            raise ValueError(\n                \"Number of rank lists must be equal to the number of weights.\"\n            )\n\n        # Associate each doc's content with its RRF score for later sorting by it\n        # Duplicated contents across retrievers are collapsed & scored cumulatively\n        rrf_score = {}\n        c = 60  # Constant used in RRF calculation\n\n        for idx, (docs, weight) in enumerate(zip(doc_lists, self.weights)):\n            for rank, doc in enumerate(docs):\n                doc_key = doc.page_content if self.id_key is None else doc.metadata[self.id_key]\n                score = weight / (rank + 1 + c)\n                if doc_key in rrf_score:\n                    rrf_score[doc_key] += score\n                else:\n                    rrf_score[doc_key] = score\n\n        all_docs = chain.from_iterable(doc_lists)\n        unique_docs = unique_by_key(all_docs, key=lambda d: d.page_content if self.id_key is None else d.metadata[self.id_key])\n        \n        sorted_docs = sorted(unique_docs, key=lambda d: rrf_score[d.page_content if self.id_key is None else d.metadata[self.id_key]], reverse=True)\n\n        return sorted_docs\n```", "type": "Development", "response": {"langchain.retrievers.ensemble.unique_by_key": "def unique_by_key(iterable: Iterable[T], key: Callable[[T], H]) -> Iterator[T]:\n    \"\"\"Yield unique elements of an iterable based on a key function.\n\n    Args:\n        iterable: The iterable to filter.\n        key: A function that returns a hashable key for each element.\n\n    Yields:\n        Unique elements of the iterable based on the key function.\n    \"\"\"\n    seen_keys = set()\n    for item in iterable:\n        k = key(item)\n        if k not in seen_keys:\n            yield item\n            seen_keys.add(k)\n", "langchain.retrievers.ensemble.EnsembleRetriever.weighted_reciprocal_rank": "    def weighted_reciprocal_rank(\n        self, doc_lists: List[List[Document]]\n    ) -> List[Document]:\n        \"\"\"\n        Perform weighted Reciprocal Rank Fusion on multiple rank lists.\n        You can find more details about RRF here:\n        https://plg.uwaterloo.ca/~gvcormac/cormacksigir09-rrf.pdf\n\n        Args:\n            doc_lists: A list of rank lists, where each rank list contains unique items.\n\n        Returns:\n            list: The final aggregated list of items sorted by their weighted RRF\n                    scores in descending order.\n        \"\"\"\n        if len(doc_lists) != len(self.weights):\n            raise ValueError(\n                \"Number of rank lists must be equal to the number of weights.\"\n            )\n\n        # Associate each doc's content with its RRF score for later sorting by it\n        # Duplicated contents across retrievers are collapsed & scored cumulatively\n        rrf_score = {}\n        c = 60  # Constant used in RRF calculation\n\n        for idx, (docs, weight) in enumerate(zip(doc_lists, self.weights)):\n            for rank, doc in enumerate(docs):\n                doc_key = doc.page_content if self.id_key is None else doc.metadata[self.id_key]\n                score = weight / (rank + 1 + c)\n                if doc_key in rrf_score:\n                    rrf_score[doc_key] += score\n                else:\n                    rrf_score[doc_key] = score\n\n        all_docs = chain.from_iterable(doc_lists)\n        unique_docs = unique_by_key(all_docs, key=lambda d: d.page_content if self.id_key is None else d.metadata[self.id_key])\n        \n        sorted_docs = sorted(unique_docs, key=lambda d: rrf_score[d.page_content if self.id_key is None else d.metadata[self.id_key]], reverse=True)\n\n        return sorted_docs\n"}}["raw_response"])
